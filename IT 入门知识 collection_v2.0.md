## 互联网/IT 入门知识 collection

### 目录

- **语言**
- **网络**
- **系统**
- **数据结构与算法**

### 正文

1. ### 语言

   **Python：**

   - **闭包与装饰器**

     ```python
     """闭包是回调式异步编程和函数式编程风格的基础"""
     def make_averager():
         series = []
         def averager(new_value):
           series.append(new_value)
           total = sum(series)
           return total/len(series)
        	return averager
     闭包的延迟绑定：
     这里的series作为make_averager函数的局部变量，会随着return的运行而失去作用域。虽然如此，但在闭包中，series可作为自由变量继续averager中的操作。所以，闭包时一种函数，会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用，但仍然使用那些绑定。
     nolocal声明：
     对于不可变类型变量，引入nolocal声明，将变量标记为自由变量

     """函数装饰器在导入模块时立即执行，而被装饰的函数旨在明确调用时运行。"""
     装饰器通常在一个模块中定义，然后应用到其他模块的函数中。
     register装饰器返回的函数与通过参数传入的相同，这里重点运用在python web框架里，把函数添加到某种中央注册处，集中管理集中调用。
     ```

   - **property属性**

     ```python
     定义：一种修饰实例方法的特殊属性，有装饰器和类属性两种变换形态
     功能：类似rest接口风格的一种修饰属性
     风格：装饰器 & 类属性
     装饰器：
     claclass Goods:
         """python3中默认继承object类
             以python2、3执行此程序的结果不同，因为只有在python3中才有@xxx.setter  @xxx.deleter
         """
         @property
         def price(self):  ## 查询
             print('@property')

         @price.setter  
         def price(self, value):  ## 修改
             print('@price.setter')

         @price.deleter
         def price(self):  ## 删除
             print('@price.deleter')

     obj = Goods()
     obj.price          # 自动执行 @property 修饰的 price 方法，并获取方法的返回值
     obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数
     del obj.price      # 自动执行 @price.deleter 修饰的 price 方法ss Goods

     类属性：
     class Foo(object):
         def get_bar(self):
             print("getter...")
             return 'laowang'

         def set_bar(self, value): 
             """必须两个参数"""
             print("setter...")
             return 'set value' + value

         def del_bar(self):
             print("deleter...")
             return 'laowang'

         BAR = property(get_bar, set_bar, del_bar, "description...")
     ```

   - with

     ```
     with操作，实现原理来自于上下文管理器，替代了try/finally，实现了文本的读取与清除。   
     ```


   - **协程**

     ```
     线程是系统级别的调度，而协程是程序级别的调度。在同一线程内一段代码在执行过程中会中断然后跳转执行别的代码，类似生成器的yield操作。
     协程拥有自己的寄存器，上下文，和栈。因此，协程能保留上一次调用时的状态，每一次过程重入时，就相当于进入上一次调用的状态。
     优点是：省掉了多线程切换的时间资源消耗，方便控制切换流，尤其擅长高并发+高扩展+低成本的开发任务。

     python3 使用yield可实现协程。
     日常使用多用gevent实现协程。
     ```

     ​

2. ### 网络

   - **WSGI 协议**

   ```
   不修改服务器和架构代码而确保可以在多个架构下运行web服务器。
   WSGI允许开发者将选择web框架和web服务器分开。可以混合匹配web服务器和web框架，选择一个适合的配对。
   ```

   - **网络字序节**

     ```
     字节序，字节的顺序，大于一个字节类型的数据在内存中的存放顺序。
     网络字节序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而保证数据在不同主机之间传输时能被正确解释。网络字节顺序采用big endian排序方式。
     big-endian：高位字节排放在内存的低地址端，低位字节排放在内存的高位置端
     传输次序：大端字节序
     ```

   - **tcp协议**

     ```
     tcp与udp的不同：
     1.面向连接
     2.有序数据传输
     3.重发丢失的数据包
     4.舍弃重复的数据包
     5.无差错的数据传输
     6.阻塞/流量控制

     三次握手和四次挥手：
     seq:序列号 建立连接
     ack:确认号 确认连接
     三次挥手：
     Client ->SYN seq=x-> Server
     Server ->ACK=1 SYN=1 ack=x+1 seq=y-> Client
     Client ->ACK=1 seq=x+1 ack=y+1 ->Server
     数据传输：
     Client ->ACK y+1-> Server
     Server ->ACK y+2-> Client
     四次挥手：
     Client(fin wait 1) ->FIN=1 seq=u-> Server
     Server(close wait) -> ACK=1 seq=v ack=u+1 -> Client(fin wait 1)
     Server(close wait) -> FIN=1 ACK=1 seq=w ack=u+1 -> Client(fin wait 2)
     Client(2 MSL wait) -> ACK=1 ack=w+1 seq=u+1 -> Server(close)

     SYN的 Flood攻击：

     TCP的抓包和数据包分析：

     TIME_WAIT的 2MSL 状态：
     2MSL 最大报文段生存时间 即两倍的 Maximum Segment Lifetime，指一个片段在网络中最大的存活时间。2MSL就是一个发送和一个回复所需的最大时间。

     如果建立连接只采用两次握手，会发生死锁。

     如果已经建立连接，但客户端突然出现故障，那么服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

     在tcp/ip协议中的数据传输过程，数据被一步步封装，然后加入信息首部， 当传送到目的端时，被一步步解封，然后获取数据。任何发出的数据包都会被分配一个序列号，以便被请求的主机能够在特定的时间内对分配的这风格序列号进行确认。

     tcp的粘包和拆包
     应用程序写入的数据大于套接字缓冲区大小，将发生拆包
     应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，还将会发生粘包
     进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将拆包
     没有及时读取套接字缓冲区数据，将发生粘包
     解决方案：
     每个报文固定200字节，如果不够补空格
     在包尾增加回车换行符进行分割
     消息头和消息体两部分组成消息

     tcp的keepalive侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当另一方断掉的时候，一直返回的都是RST，那么就释放当前链接。

     在tcp通信过程中，是不存在请求一说的，只有事务性协议，如http协议，才有请求和响应的概念。准确的说，TCP报文时承载这http请求和响应的。
     ```



- socket

  ```
  可读条件：
  1.socket的接收缓冲区中的数据字节>=socket的接收缓冲区低水位标记的当前大小
  2.在连接下，读到一半时关闭
  3.socket是一个用于监听的套接字，并且已经完成的连接数为非0
  4.有一个socket有异常错误条件待处理
  可写条件：
  把上述中的接收缓冲区换成发送缓冲区即可
  ```

  ​

- http与https**

  ```
  http使用的是明文传输数据，https则是将数据加密后再进行传输 tsl（传输层加密协议）
  https特点：
    内容加密：混合加密，中间这无法查看明文内容
    验证身份：证书认证
    保护数据完整性：防止传输的内容被中间人冒充和或者篡改
    
     http的握手协议是个门槛，要求很高水很深（12306的url采用分治方法，使用http协议通信，但用户信息传输使用https）
     https传输安全性的关键在于证书的安全性验证。数字证书包含了加密后服务器的公钥，权威机构的信息，服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名），签名计算方法以及证书对应的域名。
     验证证书的安全性过程：
     1.当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥      和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。
     2.然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示	    证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析      证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私      钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书      内容和证书签名不匹配。
  http的keep-alive 客户端将connection:keep-alive放入头信息发给服务端，且服务端接收这一信息，这个连接就可以复用了，一个http处理完之后，另外一个http数据直接从这个连接走了，减少了新建和断开TCP连接的消耗。
  ```

### **3.数据库**

- **redis**

  ```
  Redis是一款开源的、高性能的键-值存储。
    Redis的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。 对于这些数据类型，可以执行原子操作。
    为了获得优异的性能，Redis采用了内存中（in-memory）数据集（dataset）的方式。同时，Redis支持数据的持久化，你可以每隔一段时间将数据集转存到磁盘上（snapshot），或者在日志尾部追加每一条操作命令（append only file,aof）。
    Redis支持主从复制，并具有非常快速的非阻塞首次同步。网络断开自动重连功能。
    
  Redis的数据类型：
    Keys：非二进制安全的字符类型
    Values：string & lists & sets & sorted sets & hash
    string类型：redis最基本的类型，是二进制安全的
      string相关命令：
      set：key value 设置key对应的值为string类型的value，返回1表示成功，0失败
      setnx：同上，如果key已存在，返回0，（nx ——— not exist）
      get：key获取key对应的string值，如果key不存在返回nil
      getset：返回key的旧值，如果key不存在返回nil
    list类型：
      list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push,pop操作从链表的头部或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。
      hash类型redis hash是一个string类型的field和value的映射表。
      hash特别适合用于存储对象。相较于将对象的每个字段存成单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。

  Redis的持久化：
    redis是一个支持持久化的内存数据库，也就是说redis需要经常将内存中的数据同步到磁盘来保证持久化，这是相对memcache来说的一个大的优势。redis支持两种持久化方式，一种是 Snapshotting（快照）也是默认方式，另一种是Append-only file（缩写aof）的方式。
  ```



### 4.操作系统

- **进程和线程**

  ```
     进程是具有一定独立功能的程序，进程在执行过程中拥有独立的内存单元。进程是系统进行资源分配和调度的一个独立单位。进程是表示资源分配的基本单位。
     线程是进程的一个实体，是cpu调度和分派的基本单位，多个线程共享内存，可以并发形式存在，依附于一个应用程序中，为完成同一个进程而工作。
     进程间的通讯方式：
        1.管道(pipe)及有名管道(named pipe)：
        管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
        2.信号(signal)：
        信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
        SIGINT：ctrl+c 终止信号
  　　  SIGQUIT：ctrl+\ 终止信号
  　　  SIGTSTP:ctrl+z 暂停信号
  　　  SIGALRM：闹钟信号 收到此信号后定时结束，结束进程
  　　  SIGCHLD：子进程状态改变，父进程收到信号
  　　  SIGKILL：杀死信号
  　　  
        3.消息队列(message queue)：
        消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
        4.共享内存(shared memory)：
        可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
        共享内存的创建：Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存。
        nmap函数要求内核创建一个新额虚拟存储器区域，系统中最多可以有128个共享内存对象。       进程调用mmap()时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。对于共享内存映射情况，缺页异常处理程序首先在swap cache中寻找目标页（符合address_space以及偏移量的物理页），如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区(swap area)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到page cache中。进程最终将更新进程页表。
        
        5.信号量(semaphore)：
        主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
        6.套接字(socket)；
        这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。
     线程间的同步通信：
        1.锁机制（互斥锁、条件变量）
        2.信号量机制
        3.信号机制
     栈是用来保存线程的执行历史和线程的执行状态，是线程私有资源。而堆、地址、全局变量是由同一个进程内的多个线程共享。
        
  僵尸进程：
     孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
  　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
  　　如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

  　　孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。

  　　任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。
  　　
  　　僵尸进程的解决办法：
  　　	1.通过信号机制解决：子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。
  　　	2.将僵尸进程变为孤儿进程，从而父进程变为init进程，即可处理僵尸进程了。
  CPU执行方式：（先拿指令，再拿数据）0
     1.取指令阶段：将一条指令从主存储器取到指令寄存器的过程。
     2.指令译码阶段：取出指令后，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类 别以及各种获取操作数的方法。
     3.执行指令阶段：具体实现指令的功能。CPU的不同部分被连接起来，以执行所需操作。
     4.访存取数阶段：根据指令需要访问主存、读取操作数，CPU得到操作数在主存的地址，并从主存中读取该操作数用于运算。
     5.结果写回阶段：作为最后一个阶段，结果写回阶段把执行指令阶段的运行结果数据“写回”到存储中
     CPU分3个模块：控制单元、运算单元和存储单元
     控制单元：由指令寄存器、指令译码器和操作控制器组成。
     运算单元：运算器的核心，可执行算术运算和逻辑运算。
     存储单元：CPU片内缓存和寄存器组，是CPU中暂时存放数据的地方，里面保存着那些等待处理的数据。

  exit()与_exit()
     exit函数将终止调用进程。在退出程序之前，所有文件关闭，缓冲输出内容将刷新定义，并调用所有已刷新的“出口函数”（由atexit定义）。 
  _exit:该函数是由Posix定义的，不会运行exit handler和signal handler，在UNIX系统中不会flush标准I/O流。 
  简单的说，_exit终止调用进程，但不关闭文件，不清除输出缓存，也不调用出口函数。 
  共同： 
  不管进程是如何终止的，内核都会关闭进程打开的所有file descriptors,释放进程使用的memory!

  守护进程
  守护进程是一个在后台运行并且不受任何终端控制的进程。Unix操作系统有很多典型的守护进程(其数目根据需要或20—50不等)，它们在后台运行，执行不同的管理任务。
  创建流程：
  (1)创建子进程，终止父进程
  由于守护进程是脱离控制终端的，因此首先创建子进程，终止父进程，使得程序在shell终端里造成一个已经运行完毕的假象。之后所有的工作都在子进程中完成，而用户在shell终端里则可以执行其他的命令，从而使得程序以僵尸进程形式运行，在形式上做到了与控制终端的脱离。
  (2)在子进程中创建新会话
  这个步骤是创建守护进程中最重要的一步，在这里使用的是系统函数setsid。
  setsid函数用于创建一个新的会话，并担任该会话组的组长。调用setsid仃三个作用：让进程摆脱原会话的控制、让进程摆脱原进程组的控制和让进程摆脱原控制终端的控制。
  在调用fork函数时，子进程全盘拷贝父进程的会话期(session，是一个或多个进程组的集合)、进程组、控制终端等，虽然父进程退出了，但原先的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。setsid函数能够使进程完全独立出来，从而脱离所有其他进程的控制。
  (3)改变工作目录
  使用fork创建的子进程也继承了父进程的当前工作目录。由于在进程运行过程中，当前目录所在的文件系统不能卸载，因此，把当前工作目录换成其他的路径，如“/”或“/tmp”等。改变工作目录的常见函数是chdir。
  (4)重设文件创建掩码
  文件创建掩码是指屏蔽掉文件创建时的对应位。由于使用fork函数新建的子进程继承了父进程的文件创建掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件创建掩码设置为0，可以大大增强该守护进程的灵活性。设置文件创建掩码的函数是umask，通常的使用方法为umask(0)。

  进程的内存管理机制：
     进程内存管理的对象是进程线性地址空间上的内存镜像，这些内存镜像其实就是进程使用的虚拟内存区域（memory region）。进程虚拟空间是个32或64位的“平坦”（独立的连续区间）地址空间（空间的具体大小取决于体系结构）。要统一管理这么大的平坦空间可绝非易事，为了方便管理，虚拟空间被划分为许多大小可变的(但必须是4096的倍数)内存区域，这些区域在进程线性地址中像停车位一样有序排列。这些区域的划分原则是“将访问属性一致的地址空间存放在一起”，所谓访问属性在这里无非指的是“可读、可写、可执行等”。
  ```

- **linux系统 基本大操作**

  ```
  Linux netstat命令详解
  netstat 显示网络相关的信息，如网络连接，路由表(-r)，接口状态
  -a (all) 显示全部信息
  -n 拒绝别名，能用数字的都用数字

  Linux tcpdump命令详解
  对网络上的数据包进行截获的包分析工具。

  Linux ipcs命令与ipcrm命令的用法详解
  ipcs提供进程间通信方式的信息，包括共享内存，信号量，消息队列。
  -a 输出所有
  -m 共享内存
  -q 消息队列
  -s 信号

  ipcrm移除一个消息对象、或者共享内存、或者信号量
  ipcrm用法 （小写是id标识）
  ipcrm -M shmkey 移除用shmkey创建的共享内存段
  ipcrm -m shmid 移除用shmid标识的共享内存段
  ipcrm -Q msgkey 移除用msqkey创建的消息队列
  ipcrm -q msqid 移除用msqid标识的消息队列
  ipcrm -S semkey 移除用semkey创建的信号
  ipcrm -s semid 移除用semid标识的信号

  awk：awk 是一种处理文本文件的语言，是一个强大的文本分析工具。7
  sed：sed 可依照脚本的指令来处理、编辑文本文件，主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。
  ```

  ​